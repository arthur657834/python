### 内存地址
* id()：获取的是对象在内存中的地址

* is ：比对2个变量的对象引用（对象在内存中的地址，即id() 获得的值）是否相同。如果相同则返回True，否则返回False。换句话说，就是比对2个变量的对象引用是否指向同一个对象。

* ==：比对2个变量指向的对象的内容是否相同。

```python
#True
a = 1
b = 1
print(a is b)
 
#True
a = "good"
b = "good"
print(a is b)
 
#False
a = "very good morning"
b = "very good morning"
print(a is b)
 
#False
a = []
b = []
print(a is b)
```
由于Python缓存了整数和短字符串，因此每个对象只存有一份。比如，所有整数1的引用都指向同一对象。即使使用赋值语句，也只是创造了新的引用， 而不是对象本身。长的字符串和其它对象可以有多个相同的对象，可以使用赋值语句创建出新的对象。

###  获取引用计数
```python
from sys import getrefcount
# 2 
a = [1, 2, 3]
print(getrefcount(a))
# 3 
b = a
print(getrefcount(b))
# 5
c = [a, a]
print(getrefcount(a))
```

### 引用计数减少

* 1 对象的别名被显式的销毁：del x ；或者del y
* 2 对象的一个别名被赋值给其他对象：x=789
* 3 一个本地引用离开了它的作用域。比如上面的foo(x)函数结束时，x指向的对象引用减1。
* 4 对象从一个容器对象中移除：myList.remove(x)
* 5 容器对象本身被销毁：del myList，或者容器对象本身离开了作用域。


### 引用的复杂性
```python
x = [1, 2, 3]
y = [x, dict(key1=x)]
z = [y, (x, y)]
 
import objgraph
objgraph.show_refs([z], filename='ref_topo.png')
```
xdotool /tmp/objgraph-LS5YFL.dot 查看图形

### garbage collection
```python
import gc
print(gc.get_threshold())
gc.set_threshold(700, 10, 5)
```
当Python运行时，会记录其中分配对象(object allocation)和取消分配对象(object deallocation)的次数。当两者的差值高于某个阈值时，垃圾回收才会启动。

返回(700, 10, 10)，后面的两个10是与分代回收相关的阈值，后面可以看到。700即是垃圾回收启动的阈值。可以通过gc中的set_threshold()方法重新设置。

Python同时采用了分代(generation) 回收的策略。这一策略的基本假设是，存活时间越久的对象，越不可能在后面的程序中变成垃圾。我们的程序往往会产生大量的对象，许多对象很快产生和消失，但也有一些对象长期被使用。出于信任和效率，对于这样一些“长寿”对象，我们相信它们的用处，所以减少在垃圾回收中扫描它们的频率。

Python将所有的对象分为0，1，2三代。所有的新建对象都是0代对象。当某一代对象经历过垃圾回收，依然存活，那么它就被归入下一代对象。垃圾回收启动时，一定会扫描所有的0代对象。如果0代经过一定次数垃圾回收，那么就启动对0代和1代的扫描清理。当1代也经历了一定次数的垃圾回收后，那么会启动对0，1，2，即对所有对象进行扫描。

这两个次数即上面get_threshold()返回的(700, 10, 10)返回的两个10。也就是说，每10次0代垃圾回收，会配合1次1代的垃圾回收；而每10次1代的垃圾回收，才会有1次的2代垃圾回收。

我们也可以手动启动垃圾回收，即使用gc.collect()。

### 内存池机制
* 1 第-1，-2层主要由操作系统进行操作
* 2 第0层是C中的malloc，free等内存分配和释放函数进行操作
* 3 第1层和第2层是内存池，有Python的接口函数PyMem_Malloc函数实现，当对象小于256K时有该层直接分配内存；
* 4 第3层是最上层，也就是我们对Python对象的直接操作

在 C 中如果频繁的调用 malloc 与 free 时，是会产生性能问题的。再加上频繁的分配与释放小块的内存会产生内存碎片。

Python 在这里主要干的工作有：
如果请求分配的内存在1~256字节之间就使用自己的内存管理系统,否则直接使用 malloc。
这里还是会调用 malloc 分配内存，但每次会分配一块大小为256k的大块内存。
经由内存池登记的内存到最后还是会回收到内存池,并不会调用 C 的 free 释放掉。以便下次使用。

对于简单的Python对象，例如数值、字符串，元组（tuple不允许被更改)采用的是复制的方式。
